// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tracks.sql

package sqlcDb

import (
	"context"
	"database/sql"
)

const getTrackFromPath = `-- name: GetTrackFromPath :one
SELECT id, createdat, path, sourceurl, title, artist, album, genre, year, durationinms, starred, queueid FROM tracks WHERE path LIKE ?1
`

func (q *Queries) GetTrackFromPath(ctx context.Context, trackpath string) (Track, error) {
	row := q.db.QueryRowContext(ctx, getTrackFromPath, trackpath)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Path,
		&i.Sourceurl,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.Genre,
		&i.Year,
		&i.Durationinms,
		&i.Starred,
		&i.Queueid,
	)
	return i, err
}

const insertTrack = `-- name: InsertTrack :exec
INSERT INTO tracks (
    id,
    createdAt,
    path,
    sourceUrl,
    title,
    artist,
    album,
    genre,
    year,
    durationInMs,
    starred,
    queueId
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12
)
`

type InsertTrackParams struct {
	ID           string         `json:"id"`
	Createdat    int64          `json:"createdat"`
	Path         string         `json:"path"`
	Sourceurl    string         `json:"sourceurl"`
	Title        string         `json:"title"`
	Artist       string         `json:"artist"`
	Album        string         `json:"album"`
	Genre        sql.NullString `json:"genre"`
	Year         sql.NullInt64  `json:"year"`
	Durationinms sql.NullInt64  `json:"durationinms"`
	Starred      sql.NullInt64  `json:"starred"`
	Queueid      sql.NullString `json:"queueid"`
}

func (q *Queries) InsertTrack(ctx context.Context, arg InsertTrackParams) error {
	_, err := q.db.ExecContext(ctx, insertTrack,
		arg.ID,
		arg.Createdat,
		arg.Path,
		arg.Sourceurl,
		arg.Title,
		arg.Artist,
		arg.Album,
		arg.Genre,
		arg.Year,
		arg.Durationinms,
		arg.Starred,
		arg.Queueid,
	)
	return err
}

const listAllTracks = `-- name: ListAllTracks :many
SELECT id, createdat, path, sourceurl, title, artist, album, genre, year, durationinms, starred, queueid FROM tracks ORDER by title
`

func (q *Queries) ListAllTracks(ctx context.Context) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listAllTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Path,
			&i.Sourceurl,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Genre,
			&i.Year,
			&i.Durationinms,
			&i.Starred,
			&i.Queueid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavTracks = `-- name: ListFavTracks :many
SELECT id, createdat, path, sourceurl, title, artist, album, genre, year, durationinms, starred, queueid FROM tracks WHERE starred IS NOT NULL ORDER by title
`

func (q *Queries) ListFavTracks(ctx context.Context) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listFavTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Path,
			&i.Sourceurl,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Genre,
			&i.Year,
			&i.Durationinms,
			&i.Starred,
			&i.Queueid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksByAlbum = `-- name: ListTracksByAlbum :many
SELECT id, createdat, path, sourceurl, title, artist, album, genre, year, durationinms, starred, queueid FROM tracks WHERE album =?1
`

func (q *Queries) ListTracksByAlbum(ctx context.Context, albumname string) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksByAlbum, albumname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Path,
			&i.Sourceurl,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Genre,
			&i.Year,
			&i.Durationinms,
			&i.Starred,
			&i.Queueid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksByArtist = `-- name: ListTracksByArtist :many
SELECT id, createdat, path, sourceurl, title, artist, album, genre, year, durationinms, starred, queueid FROM tracks WHERE artist LIKE ?1 ORDER by title
`

func (q *Queries) ListTracksByArtist(ctx context.Context, artist string) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksByArtist, artist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Path,
			&i.Sourceurl,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Genre,
			&i.Year,
			&i.Durationinms,
			&i.Starred,
			&i.Queueid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksByPlaylist = `-- name: ListTracksByPlaylist :many
SELECT
    t.id, 
    t.createdAt, 
    t.path, 
    t.sourceUrl, 
    t.title, 
    t.artist, 
    t.album, 
    t.genre, 
    t.year, 
    t.durationInMs, 
    t.starred, 
    t.queueId
FROM 
    tracks_to_playlists AS ttp
JOIN 
    tracks AS t ON ttp.trackId = t.id
WHERE 
    ttp.playlistId = ?1
ORDER BY 
    t.title
`

func (q *Queries) ListTracksByPlaylist(ctx context.Context, playlistid string) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksByPlaylist, playlistid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Path,
			&i.Sourceurl,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Genre,
			&i.Year,
			&i.Durationinms,
			&i.Starred,
			&i.Queueid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const starTrack = `-- name: StarTrack :exec
UPDATE tracks SET starred = unixepoch() WHERE id = ?1
`

func (q *Queries) StarTrack(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, starTrack, id)
	return err
}
