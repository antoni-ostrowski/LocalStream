// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tracks.sql

package sqlcDb

import (
	"context"
	"database/sql"
)

const getTrackFromPath = `-- name: GetTrackFromPath :one
SELECT id, created_at, path, title, artist, album, genre, year, duration_in_ms, starred, queue_id, is_missing FROM tracks WHERE path LIKE ?1
`

func (q *Queries) GetTrackFromPath(ctx context.Context, trackPath string) (Track, error) {
	row := q.db.QueryRowContext(ctx, getTrackFromPath, trackPath)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Path,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.Genre,
		&i.Year,
		&i.DurationInMs,
		&i.Starred,
		&i.QueueID,
		&i.IsMissing,
	)
	return i, err
}

const insertTrack = `-- name: InsertTrack :exec
INSERT INTO tracks (
    id,
    created_at,
    path,
    -- sourceDir,
    title,
    artist,
    album,
    genre,
    year,
    duration_in_ms,
    starred,
    queue_id,
    is_missing
) VALUES (
    ?1,
    ?2,
    ?3,
    -- sqlc.arg(sourceDir),
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12
)
`

type InsertTrackParams struct {
	ID           string         `json:"id"`
	CreatedAt    int64          `json:"created_at"`
	Path         string         `json:"path"`
	Title        string         `json:"title"`
	Artist       string         `json:"artist"`
	Album        string         `json:"album"`
	Genre        sql.NullString `json:"genre"`
	Year         sql.NullInt64  `json:"year"`
	DurationInMs sql.NullInt64  `json:"duration_in_ms"`
	Starred      sql.NullInt64  `json:"starred"`
	QueueID      sql.NullString `json:"queue_id"`
	IsMissing    sql.NullBool   `json:"is_missing"`
}

func (q *Queries) InsertTrack(ctx context.Context, arg InsertTrackParams) error {
	_, err := q.db.ExecContext(ctx, insertTrack,
		arg.ID,
		arg.CreatedAt,
		arg.Path,
		arg.Title,
		arg.Artist,
		arg.Album,
		arg.Genre,
		arg.Year,
		arg.DurationInMs,
		arg.Starred,
		arg.QueueID,
		arg.IsMissing,
	)
	return err
}

const listAllTracks = `-- name: ListAllTracks :many
SELECT id, created_at, path, title, artist, album, genre, year, duration_in_ms, starred, queue_id, is_missing FROM tracks ORDER by title
`

func (q *Queries) ListAllTracks(ctx context.Context) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listAllTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Path,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Genre,
			&i.Year,
			&i.DurationInMs,
			&i.Starred,
			&i.QueueID,
			&i.IsMissing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavTracks = `-- name: ListFavTracks :many
SELECT id, created_at, path, title, artist, album, genre, year, duration_in_ms, starred, queue_id, is_missing FROM tracks WHERE starred IS NOT NULL ORDER by title
`

func (q *Queries) ListFavTracks(ctx context.Context) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listFavTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Path,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Genre,
			&i.Year,
			&i.DurationInMs,
			&i.Starred,
			&i.QueueID,
			&i.IsMissing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksByAlbum = `-- name: ListTracksByAlbum :many
SELECT id, created_at, path, title, artist, album, genre, year, duration_in_ms, starred, queue_id, is_missing FROM tracks WHERE album = ?1
`

func (q *Queries) ListTracksByAlbum(ctx context.Context, albumName string) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksByAlbum, albumName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Path,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Genre,
			&i.Year,
			&i.DurationInMs,
			&i.Starred,
			&i.QueueID,
			&i.IsMissing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksByArtist = `-- name: ListTracksByArtist :many
SELECT id, created_at, path, title, artist, album, genre, year, duration_in_ms, starred, queue_id, is_missing FROM tracks WHERE artist LIKE ?1 ORDER by title
`

func (q *Queries) ListTracksByArtist(ctx context.Context, artist string) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksByArtist, artist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Path,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Genre,
			&i.Year,
			&i.DurationInMs,
			&i.Starred,
			&i.QueueID,
			&i.IsMissing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksByPlaylist = `-- name: ListTracksByPlaylist :many
SELECT
    t.id, 
    t.created_at, 
    t.path, 
    -- t.sourceDir, 
    t.title, 
    t.artist, 
    t.album, 
    t.genre, 
    t.year, 
    t.duration_in_ms, 
    t.starred, 
    t.queue_id,
    t.is_missing
FROM 
    tracks_to_playlists AS ttp
JOIN 
    tracks AS t ON ttp.track_id = t.id
WHERE 
    ttp.playlist_id = ?1
ORDER BY 
    t.title
`

func (q *Queries) ListTracksByPlaylist(ctx context.Context, playlistID string) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksByPlaylist, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Path,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Genre,
			&i.Year,
			&i.DurationInMs,
			&i.Starred,
			&i.QueueID,
			&i.IsMissing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const starTrack = `-- name: StarTrack :exec
UPDATE tracks SET starred = unixepoch() WHERE id = ?1
`

func (q *Queries) StarTrack(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, starTrack, id)
	return err
}

const updateTrack = `-- name: UpdateTrack :exec
UPDATE tracks SET
    title = ?1,
    artist = ?2,
    album = ?3,
    genre = ?4,
    year = ?5,
    duration_in_ms = ?6,
    is_missing = ?7
WHERE id = ?8
`

type UpdateTrackParams struct {
	Title        string         `json:"title"`
	Artist       string         `json:"artist"`
	Album        string         `json:"album"`
	Genre        sql.NullString `json:"genre"`
	Year         sql.NullInt64  `json:"year"`
	DurationInMs sql.NullInt64  `json:"duration_in_ms"`
	IsMissing    sql.NullBool   `json:"is_missing"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateTrack(ctx context.Context, arg UpdateTrackParams) error {
	_, err := q.db.ExecContext(ctx, updateTrack,
		arg.Title,
		arg.Artist,
		arg.Album,
		arg.Genre,
		arg.Year,
		arg.DurationInMs,
		arg.IsMissing,
		arg.ID,
	)
	return err
}
